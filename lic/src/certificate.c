/**
 * @copyright Copyright (c) 2023
 * @file certificate.c
 * @author hhool (hhool@outlook.com)
 * @version 0.1
 * @date 2023-12-01
 * @brief license certificate for aamr module that generated by license tool.
 *      The certificate is encrypted by AES-128-CBC, and the key is "aamr1234".
 *      The certificate is generated by license tool and stored in the file
 *      dst aamr module g_certificate.
 */

#include "certificate.h"
#include <openssl/aes.h>
#include <string.h>

// certificate size: 16 * 4, contains 8 bytes "MAGICNUM" and 120 bytes value.
// 8 (magic_num) + 120(cert_value) = 128
// Header MAGICNUM: 0x4D, 0x41, 0x47, 0x49, 0x43, 0x4E, 0x55, 0x4D "MAGICNUM"
// Value: 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
uint8_t g_certificate[LIC_CERTIFICATE_SIZE] = {
    0x4D, 0x41, 0x47, 0x49, 0x43, 0x4E, 0x55, 0x4D,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

void lic_PrintCertificate(uint8_t src[LIC_CERTIFICATE_SIZE]) {
  for (int i = 0; i < LIC_CERTIFICATE_SIZE; i++) {
    printf("%02x ", src[i]);
    if ( i % 16 == 15) {
      printf("\n");
    }
  }
}

void lic_CheckCertificateMagicNum(uint8_t src[LIC_CERTIFICATE_SIZE],
                                  int32_t *has_magic_num) {
  uint8_t magic_num[8] = {0x4D, 0x41, 0x47, 0x49, 0x43, 0x4E, 0x55, 0x4D};
  if (memcmp(src, magic_num, 8) != 0) {
    *has_magic_num = FALSE;
  }
  *has_magic_num = TRUE;
}

void lic_CheckCertificateValueInited(uint8_t src[LIC_CERTIFICATE_SIZE],
                                     int32_t *is_inited) {
  int32_t has_magic_num = FALSE;
  lic_CheckCertificateMagicNum(src, &has_magic_num);
  if (has_magic_num == FALSE) {
    printf("Certificate has no magic num!\n");
    *is_inited = TRUE;
    return;
  }
  for (int i = 8; i < LIC_CERTIFICATE_SIZE; i++) {
    if (src[i] != 0xFF) {
      *is_inited = TRUE;
      printf("Certificate has been inited!\n");
      return;
    }
  }
  *is_inited = FALSE;
}

void lic_GetCertificate(uint8_t dst[LIC_CERTIFICATE_SIZE]) {
  memcpy(dst, g_certificate, sizeof(g_certificate));
}

void lic_SetCertificate(uint8_t src[LIC_CERTIFICATE_SIZE]) {
  memcpy(g_certificate, src, sizeof(g_certificate));
}

int32_t lic_EncryptCertificate(uint8_t src[LIC_CERTIFICATE_SIZE],
                               const uint8_t *key_private,
                               uint8_t dst[LIC_CERTIFICATE_SIZE]) {
  AES_KEY aes;
  uint8_t iv[AES_BLOCK_SIZE];
  memset(iv, 0x00, AES_BLOCK_SIZE);
  AES_set_encrypt_key(key_private, 128, &aes);
  AES_cbc_encrypt(src, dst, LIC_CERTIFICATE_SIZE, &aes, iv, AES_ENCRYPT);
  return 0;
}

int32_t lic_DecryptCertificate(uint8_t src[LIC_CERTIFICATE_SIZE],
                               const uint8_t *key_private,
                               uint8_t dst[LIC_CERTIFICATE_SIZE]) {
  AES_KEY aes;
  uint8_t iv[AES_BLOCK_SIZE];
  memset(iv, 0x00, AES_BLOCK_SIZE);
  AES_set_decrypt_key(key_private, 128, &aes);
  AES_cbc_encrypt(src, dst, LIC_CERTIFICATE_SIZE, &aes, iv, AES_DECRYPT);
  return 0;
}

int32_t lic_EncryptCertificateByDefaultKey(uint8_t src[LIC_CERTIFICATE_SIZE],
                                           uint8_t dst[LIC_CERTIFICATE_SIZE]) {
  return lic_EncryptCertificate(src, (const uint8_t *)"aamr1234", dst);
}

int32_t lic_DecryptCertificateByDefaultKey(uint8_t src[LIC_CERTIFICATE_SIZE],
                                           uint8_t dst[LIC_CERTIFICATE_SIZE]) {
  return lic_DecryptCertificate(src, (const uint8_t *)"aamr1234", dst);
}

void lic_EncryptCertificateByDefaultKeyAndSet(
    uint8_t src[LIC_CERTIFICATE_SIZE]) {
  lic_EncryptCertificateByDefaultKey(src, g_certificate);
}

void lic_DecryptCertificateByDefaultKeyAndSet(
    uint8_t src[LIC_CERTIFICATE_SIZE]) {
  lic_DecryptCertificateByDefaultKey(src, g_certificate);
}

///////////////////////////////////////////////////////////////////////////////
/// below is for debug and test
/// @brief
/// @param filename
void lic_SaveCertificate(const char *filename) {
  FILE *fp = fopen(filename, "wb");
  if (fp == NULL) {
    return;
  }
  fwrite(g_certificate, 1, sizeof(g_certificate), fp);
  fclose(fp);
}

void lic_LoadCertificate(const char *filename) {
  FILE *fp = fopen(filename, "rb");
  if (fp == NULL) {
    return;
  }
  fread(g_certificate, 1, sizeof(g_certificate), fp);
  fclose(fp);
}

void lic_EncryptCertificateByDefaultKeyAndSetAndSave(
    uint8_t src[LIC_CERTIFICATE_SIZE], const char *filename) {
  lic_EncryptCertificateByDefaultKeyAndSet(src);
  lic_SaveCertificate(filename);
}

void lic_DecryptCertificateByDefaultKeyAndSetAndSave(
    uint8_t src[LIC_CERTIFICATE_SIZE], const char *filename) {
  lic_DecryptCertificateByDefaultKeyAndSet(src);
  lic_SaveCertificate(filename);
}

void lic_EncryptCertificateByDefaultKeyAndSetAndSaveAndLoad(
    uint8_t src[LIC_CERTIFICATE_SIZE], const char *filename) {
  lic_EncryptCertificateByDefaultKeyAndSetAndSave(src, filename);
  lic_LoadCertificate(filename);
}

void lic_DecryptCertificateByDefaultKeyAndSetAndSaveAndLoad(
    uint8_t src[LIC_CERTIFICATE_SIZE], const char *filename) {
  lic_DecryptCertificateByDefaultKeyAndSetAndSave(src, filename);
  lic_LoadCertificate(filename);
}

void lic_EncryptCertificateByDefaultKeyAndSetAndSaveAndLoadAndSet(
    uint8_t src[LIC_CERTIFICATE_SIZE], const char *filename) {
  lic_EncryptCertificateByDefaultKeyAndSetAndSaveAndLoad(src, filename);
  lic_SetCertificate(src);
}
